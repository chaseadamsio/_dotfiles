"""
" alias: .config/nvim/init.vim
"""
set nocompatible
filetype off
set omnifunc=syntaxcomplete#Complete

" Source Configuration files, ripped from
function! s:SourceConfigFilesIn(file)
  let directory_splat = '~/workspace/src/github.com/chaseadamsio/dotfiles/configs/nvim/' . a:file
  for config_file in split(glob(directory_splat), '\n')
    if filereadable(config_file)
        execute 'source' config_file
    endif
  endfor
endfunction

" Plugins are each listed in their own file. Loop and source ftw
"----------------------------------------------------------------
call s:SourceConfigFilesIn('plugins.vim')

" ctrlp ignore
set runtimepath^=~/.vim/bundle/ctrlp.vim
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,node_modules,coverage
let ctrlp_show_hidden = 1

set number " Line Numbers
set relativenumber " Relative Line Numbers

set winwidth=84
set winheight=5
set winminheight=5
set winheight=999

set shiftround " When at 3 spaces and I hit >>, go to 4, not 5.

set nofoldenable " Say no to code folding...

" Clear highlinghting on incsearch results
nmap <leader>hh :noh<cr>

let base16colorspace=256
syntax enable
set background=dark
colorscheme base16-ocean
set nowrap " no wrap
set cursorline " Highlight current line

" Change mapleader
let mapleader = ","
" Set local map leader: http://learnvimscriptthehardway.stevelosh.com/chapters/06.html
let maplocalleader="\\"

" Open .vimrc while in another file and focus on vimrc quickly adding a command
nmap <leader>ev :split $MYVIMRC<cr> <c-w>r

" Quickly source your vimrc
nmap <leader>sv :source $MYVIMRC<cr>

" Open vim-cheat-sheet
nnoremap <leader>cht :tabedit ~/Documents/Notes/vim-cheat-sheet.md<cr> <c-w>r

" Map 0 to go to beginning of test
nmap 0 ^

" Sane default for moving over lines that are wrapped
nmap k gk
nmap j gj

" Sane home row escape
imap jk <esc>

" hack for two things:
" a clean new line if in comment block
" the ability to be inside of a line and start a new line below
imap <c-c> <esc>$o<esc>^c$

set backupdir=~/.tmp
set directory=~/.tmp

" tabs and stuff----------------------------------------------------------- {{{
set shiftwidth=2
set tabstop=2
set softtabstop=2
set expandtab
"}}}

" Disable escape and arrow keys
inoremap <Left>  <NOP>
inoremap <Right> <NOP>
inoremap <Up>    <NOP>
inoremap <Down>  <NOP>
nnoremap <Left>  <NOP>
nnoremap <Right> <NOP>
nnoremap <Up>    <NOP>
nnoremap <Down>  <NOP>
" }}}

" Markdown --- {{{
:au BufNewFile,BufRead *.md set wrap

" By default, vim thinks .md is Modula-2.
autocmd BufNewFile,BufReadPost *.md set filetype=markdown

" Without this, vim breaks in the middle of words when wrapping
autocmd FileType markdown setlocal nolist wrap lbr
"  }}}

nmap <leader>pj :split package.json<CR>

" air-line
let g:airline_powerline_fonts = 1
let g:airline#extensions#syntastic#enabled=1
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
" unicode symbols
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
let g:airline_symbols.linenr = '¶'
let g:airline_symbols.branch = '⎇'
let g:airline_symbols.paste = 'ρ'
let g:airline_symbols.paste = 'Þ'
let g:airline_symbols.paste = '∥'
let g:airline_symbols.whitespace = 'Ξ' " airline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = ''
let g:airline_theme='base16'
set laststatus=2

" syntastic
let g:syntastic_check_on_open=1
let g:syntastic_enable_signs=1

" " for javacript
let g:syntastic_javascript_checkers = ['eslint', 'flow']

set ofu=syntaxcomplete#Complete
let g:syntastic_mode_map={ 'mode': 'active',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': ['html', 'cpp'] }
let g:syntastic_check_on_open=1

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

let g:syntastic_error_symbol = "✗"
let g:syntastic_warning_symbol = "⚠"

set fillchars=vert:\│
set cursorline

let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1

let g:notes_directories = ['~/Documents/Notes', '~/Dropbox/Shared Notes']

" From http://vim.wikia.com/wiki/Automatically_quit_Vim_if_quickfix_window_is_the_last
" This is a "fix" for when flow quickfix window opens to close it
" automatically
" ----------------------------------------------------------------------------
au BufEnter * call MyLastWindow()
function! MyLastWindow()
  " if the window is quickfix go on
  if &buftype=="quickfix"
    " if this window is last on screen quit without warning
    if winbufnr(2) == -1
      quit!
    endif
  endif
endfunction

" From http://stackoverflow.com/questions/8663829/vim-ctrlp-vim-plugin-how-to-rescan-files
" CtrlP auto cache clearing.
" ----------------------------------------------------------------------------
function! SetupCtrlP()
  if exists("g:loaded_ctrlp") && g:loaded_ctrlp
    augroup CtrlPExtension
      autocmd!
      autocmd FocusGained  * CtrlPClearCache
      autocmd BufWritePost * CtrlPClearCache
    augroup END
  endif
endfunction
if has("autocmd")
  autocmd VimEnter * :call SetupCtrlP()
endif

" for vim-tmux-runner integration with syntastic: https://github.com/christoomey/vim-tmux-runner
let g:VtrStripLeadingWhitespace = 0
let g:VtrClearEmptyLines = 0
let g:VtrAppendNewline = 1

" UltiSnips settings
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" format with goimports instead of gofmt
let g:go_fmt_command = "goimports"
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1
let g:go_highlight_interfaces = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1
let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go']  }
let g:go_list_type = "quickfix"

" enable neocomplete 
let g:neocomplete#enable_at_startup = 1
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

au FileType go nmap <leader>r <Plug>(go-run)
au FileType go nmap <leader>b <Plug>(go-build)
au FileType go nmap <leader>t <Plug>(go-test)
au FileType go nmap <leader>c <Plug>(go-coverage)


map <C-n> :cnext<CR>
map <C-m> :cprevious<CR>
nnoremap <leader>a :cclose<CR>
" EXPERIMENTAL...THIS stuff may not work
inoremap <C-CR> <C-O>o
